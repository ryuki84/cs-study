# Connection Pool → Thread → GC Chain
(DB 커넥션 풀 지연이 JVM/GC로 확산되는 연쇄 흐름)

## 1. 개념 정리
백엔드 서버에서 하나의 요청은
대체로 다음 자원을 순차적으로 점유한다.

- WAS 스레드
- DB 커넥션 (Connection Pool)
- Heap 메모리 (요청/응답 객체)

DB 커넥션 풀이 병목이 되면,
요청은 처리되지 못한 채 대기하며
이 대기가 스레드, 메모리, GC까지 연쇄적으로 영향을 미친다.

즉,
DB 병목은 DB에서 끝나지 않고
JVM 전체 성능 문제로 확산될 수 있다.

---

## 2. 왜 중요한가
운영 장애에서 자주 보이는 패턴은 다음과 같다.

- DB 응답 지연 발생
- 커넥션 풀 고갈
- 요청 스레드 대기 증가
- 요청 객체 Heap에 적재
- GC 빈도 증가 및 STW 지연
- 전체 응답 시간 급증

이 흐름을 이해하지 못하면
문제 원인을 GC나 JVM 튜닝으로만 오해하게 된다.

실제 원인은 DB 또는 트랜잭션 설계인 경우가 많다.

---

## 3. 백엔드 실무 관점
연쇄 흐름을 단계별로 보면 다음과 같다.

### 1) Connection Pool 병목
- 트랜잭션 시작 시 커넥션 점유
- 트랜잭션 지연으로 반환 늦어짐
- 풀의 최대 커넥션 수 도달

### 2) Thread 대기 증가
- 요청 스레드가 커넥션 대기 상태로 전환
- WAS 스레드 풀에서 유휴 스레드 감소
- 신규 요청이 큐에 적체

### 3) Heap 사용량 증가
- 대기 중인 요청/응답 객체가 Heap에 유지
- 임시 객체 생성 누적
- Old 영역으로 객체 승격 증가

### 4) GC 압박 및 STW
- Heap 사용량 증가로 GC 빈도 상승
- Full GC 발생 가능성 증가
- STW로 응답 지연이 더 악화

이 과정은
트래픽이 증가할수록 가속된다.

---

## 4. 트레이드오프 / 주의사항
- 커넥션 풀을 무작정 늘리면 DB 과부하 발생
- 스레드 풀을 키우면 Heap 사용량 증가
- GC 튜닝만으로는 근본 해결 불가

즉,
> 병목은 한 지점에서 시작되지만,
> 해결은 시스템 전반의 균형 설계가 필요하다.

라는 트레이드오프가 존재한다.

---

## 5. 예상 면접 질문 & 답변 연습

### Q1. DB 지연이 왜 GC 문제로 이어질 수 있나요?
A.
DB 커넥션 대기로 스레드가 묶이면
요청 객체가 Heap에 쌓여 메모리 사용량이 증가하고,
그 결과 GC 빈도와 STW 시간이 증가할 수 있습니다.

---

### Q2. 커넥션 풀 고갈 시 어떤 현상이 발생하나요?
A.
요청 스레드가 커넥션을 기다리며 대기하게 되고,
동시 처리량 감소와 응답 지연이 발생합니다.

---

### Q3. 이 연쇄 문제를 어떻게 예방하나요?
A.
트랜잭션 범위를 최소화하고,
외부 호출을 분리하며,
적절한 커넥션 풀 크기와 타임아웃을 설정해
병목 확산을 차단합니다.

---

## 6. 한 문장 요약 (면접용)
DB 커넥션 풀 병목은
스레드 대기와 Heap 증가를 거쳐
GC 지연으로 확산되는
대표적인 백엔드 연쇄 장애 패턴이다.
